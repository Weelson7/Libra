# Libra v2.0 Plan — Anonymous, Encrypted, Decentralized Messaging

## Overview
Libra v2.0 introduces robust global peer connectivity with full anonymity, encrypted communication, Tor-based alias beacons for discovery, and direct peer-to-peer messaging when possible.

---

## Goals & Quality Gates
- **Full anonymity between peers:** Only username and alias (three-word phrase) are shared; IP addresses are obfuscated via Tor.
- **End-to-end encrypted communication:** All messages and metadata are encrypted using strong cryptography.
- **Tor for peer connection:** Peers connect and discover each other using Tor onion services, accessed via alias beacons.
- **Direct peer-to-peer communication:** After initial rendezvous, peers attempt direct encrypted P2P connection; fallback to Tor if direct connection fails.
- **Complete isolation and encapsulation:** Libra runs in a fully isolated environment when exposed to the internet, preventing malicious activity and unauthorized access to sensitive data.

---

## Phases & Deliverables

### PHASE 1: Tor Integration & Onion Service Setup
- Integrate Tor client (Stem for control, system Tor for performance).
- Enable each peer to run an ephemeral onion service for incoming connections (faster startup than persistent services).
- Securely generate and manage onion addresses (v3 onion addresses for better performance).
- Add configuration for Tor usage (enable/disable, custom Tor path, circuit timeout tuning).
- Implement connection pooling and circuit reuse to minimize Tor handshake overhead.
- **Isolation:** Run Tor process in separate isolated environment (container, sandbox, or dedicated user with minimal permissions).

### PHASE 2: Alias Beacon System
- Implement alias-based beacon system (three-word phrase → onion address).
- Allow users to publish and lookup aliases securely.
- Support private and public alias beacons.

### PHASE 3: Secure Rendezvous & Metadata Exchange
- Exchange public keys, session info, and NAT traversal data over Tor.
- Use authenticated encryption for all rendezvous messages.
- Enforce rate limiting and authentication for onion service endpoints.
- Implement message batching to reduce round trips over Tor.
- Use lightweight serialization (msgpack, protobuf) to minimize payload size and transfer time.

### PHASE 4: Direct Peer-to-Peer Connection Attempt
- Use exchanged info to attempt direct encrypted P2P connection (WebRTC, TCP, UDP hole punching).
- Prioritize direct connection attempts in parallel with Tor communication to minimize latency.
- If successful, switch to direct channel for messaging and file transfer.
- Monitor connection health and auto-fallback to Tor if direct channel fails.
- Use aggressive connection timeouts (e.g., 5-10 seconds) to quickly fallback to Tor if direct connection stalls.

### PHASE 5: Tor Transport Fallback
- If direct connection fails, continue communication over Tor onion service.
- Optimize Tor transport for messaging:
  - Use persistent Tor circuits to avoid repeated circuit building.
  - Implement stream multiplexing (single circuit, multiple logical streams).
  - Chunk large messages/files and pipeline transfers.
  - Compress data before transmission to reduce bandwidth and latency.
- Support persistent Tor sessions for long-running conversations.
- Cache Tor circuit paths and use Tor's circuit prediction features for faster subsequent connections.

### PHASE 6: Security & Privacy Hardening

#### Network Isolation & Encapsulation
- Run Libra in a completely isolated environment when exposed to the internet:
  - Container-based isolation (Docker, Podman) with minimal base image.
  - Sandboxed execution (Firejail, AppArmor, SELinux policies).
  - Separate user account with restricted permissions (no sudo, no file system access beyond designated directories).
- Isolate Tor processes in separate containers/sandboxes from main Libra application.
- Implement network namespace isolation to prevent unauthorized network access.
- Use seccomp filters to restrict system calls to minimum required set.

#### Data Protection
- Encrypt all local data at rest (database, keys, logs, temporary files).
- Store sensitive data only in encrypted memory (use mlock to prevent swapping to disk).
- Implement secure memory wiping for cryptographic material after use.
- No sensitive data logged or exposed to host system.
- Temporary files stored in encrypted tmpfs or memory-only filesystem.

#### Network Security
- Enforce TLS 1.3 for all direct peer connections with certificate pinning.
- Implement strict firewall rules: only allow outbound Tor connections and authenticated peer connections.
- No listening on public interfaces except through Tor onion service.
- Rate limiting on all incoming connections to prevent DoS attacks.
- Validate and sanitize all incoming messages and metadata.

#### Application Security
- Input validation on all user inputs and network messages.
- No code execution from external sources (disable eval, exec, dynamic imports).
- Use memory-safe libraries where possible.
- Regular dependency scanning for known vulnerabilities.
- Implement intrusion detection for suspicious behavior patterns.

#### Privacy Hardening
- Rotate onion addresses periodically for enhanced privacy.
- Audit for metadata leaks and timing attacks.
- Prevent fingerprinting via traffic analysis (constant-rate dummy traffic option).
- No telemetry or analytics; all data stays local.

### PHASE 7: User Experience & Configuration
- UI/CLI for managing Tor status, onion address, and connection preferences.
- Alias generation and sharing (QR code, three-word phrase).
- Connection status indicators (Tor, direct, fallback).
- Documentation for Tor setup and troubleshooting.

### PHASE 8: Testing & Quality Gates

#### Connectivity Testing
- Test global peer discovery and connection across NAT/firewall scenarios.
- Benchmark latency and throughput for Tor vs. direct connections.
- User acceptance testing for setup and connection workflow.

#### Security Testing
- **Penetration Testing:**
  - Attempt to escape sandbox/container isolation.
  - Test for privilege escalation vulnerabilities.
  - Fuzzing all network inputs and message parsers.
  - Attempt to access host filesystem or sensitive data.
  - Test for memory leaks and buffer overflows.
- **Privacy Analysis:**
  - Verify no IP address leaks or metadata exposure.
  - Traffic analysis resistance testing.
  - Timing attack vulnerability assessment.
- **Isolation Verification:**
  - Confirm Libra cannot access host system resources beyond designated directories.
  - Verify Tor process isolation from main application.
  - Test firewall rules and network restrictions.
- **Data Protection Audit:**
  - Verify all sensitive data is encrypted at rest.
  - Check for plaintext secrets in memory dumps.
  - Confirm secure memory wiping of cryptographic material.
- **Dependency Security:**
  - Scan all dependencies for known CVEs.
  - Verify cryptographic library versions and configurations.
  - Check for supply chain vulnerabilities.

---

## Critical Success Factors
1. **Global Connectivity:** Peers can always connect, regardless of network restrictions.
2. **Anonymity:** Onion services and encrypted channels protect user identity and data.
3. **Performance:** Direct connections preferred for speed; Tor fallback ensures reliability.
4. **Security & Isolation:** Complete encapsulation when exposed to internet; no metadata leaks, strong authentication, sandboxed execution, and encrypted data at rest.
5. **User Control:** Users choose discovery mode, manage aliases, and configure privacy.
6. **Attack Resistance:** Robust defense against malicious peers, DoS attacks, and exploitation attempts.

---

## Summary Timeline
- **Phases 1-3:** 2-3 weeks (Tor integration, alias beacons, rendezvous)
- **Phases 4-5:** 2 weeks (Direct P2P, fallback logic)
- **Phases 6-7:** 2 weeks (Security, UX)
- **Phase 8:** 2 weeks (Testing, audit)

**Total: ~8-9 weeks** (single developer estimate)

---

## Appendix: Implementation Notes
- Use Tor for all initial peer connections and metadata exchange.
- Only username and alias are exposed; IP addresses are never revealed.
- All communication is encrypted end-to-end.
- Direct P2P is attempted for performance; fallback to Tor for reliability and privacy.
- Alias beacons are unique, easy to share, and can be private or public.
- Security and privacy are enforced at every layer.

### Performance Optimization Strategies for Tor
1. **Ephemeral Onion Services:** Faster startup than persistent services; no need for disk I/O.
2. **Circuit Reuse:** Reuse existing Tor circuits to avoid repeated handshake overhead (~3-6 seconds per circuit).
3. **Connection Pooling:** Maintain persistent connections to reduce latency for repeated requests.
4. **Parallel Direct Connection Attempts:** Start direct P2P connection attempts immediately, don't wait for Tor-only communication to complete.
5. **Aggressive Timeouts:** Use short timeouts (5-10s) to quickly detect failed direct connections and fallback to Tor.
6. **Message Batching:** Combine multiple small messages into single transmissions to reduce round trips.
7. **Lightweight Serialization:** Use msgpack or protobuf instead of JSON to reduce payload size.
8. **Data Compression:** Compress messages and files before transmission to reduce bandwidth and latency.
9. **Stream Multiplexing:** Use single Tor circuit for multiple logical streams to avoid circuit building overhead.
10. **Circuit Prediction:** Leverage Tor's circuit prediction features to pre-build circuits for anticipated connections.

### Security Isolation & Encapsulation Strategies
1. **Container Isolation:** Run Libra in Docker/Podman with minimal base image, read-only root filesystem, and no privileged mode.
2. **Sandbox Execution:** Use Firejail, AppArmor, or SELinux to restrict system calls and file system access.
3. **Network Namespace Isolation:** Separate network stack to prevent unauthorized access to host network.
4. **Principle of Least Privilege:** Run as non-root user with minimal permissions; drop capabilities after startup.
5. **Encrypted Storage:** All local data encrypted at rest using strong encryption (AES-256).
6. **Memory Protection:** Use mlock for sensitive data, secure memory wiping, and prevent core dumps.
7. **Firewall Rules:** Strict iptables/nftables rules allowing only necessary outbound connections.
8. **Input Validation:** Comprehensive validation and sanitization of all external inputs.
9. **Dependency Isolation:** Pin dependency versions, verify checksums, and use dependency scanning tools.
10. **Intrusion Detection:** Monitor for suspicious activity patterns and automatically quarantine/alert.
11. **No Data Exfiltration:** No telemetry, analytics, or external logging; all data stays local and encrypted.
12. **Secure Defaults:** Security features enabled by default; users must explicitly opt-out (with warnings).
